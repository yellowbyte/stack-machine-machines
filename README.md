# stack-machine-machines

This repository contains implementations of a stack-based compiler in different programming languages. A stack-based compiler performs a single-pass through the source code and generates code as it sees it with a stack data structure. The stack is the primary data structure in a stack-based compiler and therefore its current state state represents the current state of computation. A stack-based compiler is elegant and easy-to-reason, but does not generate optimized code because it generates code "right as it sees it." However, because of its elegance, I figure it would be a good medium for me to explore different programming languages, different paradigms, and the different language featuers that are enabled by those paradigms. 

A programming language is a medium that allows one to interact with a general-purpose computer without having to code in that computer's "native" language. That is because the language that a computer speaks in, zeros and ones, is not one that is intuitive to us. Perhaps nowsaday people don't consider assembly languages as a programming language, but in essence, it is. Assembly languages free us from using the obscure zeros and ones to interact with the computer to using the easier-to-remember words (i.e., mnemonics) to interact instead. The transition to programming in assembly was intuitive since it made the software development lifecycle faster, but most importantly, with zero performance penalty since an assembler translates one assembly instruction to exactly one machine code instruction. Programming in a higher-level language was a completely different story. A higher-level programming statement can be translated to multiple machine code instructions and different compiler implementations for the same language also meant different sets of machine code output. Early skepticism of compiled langauges was inevitable since compiler was not able to generate code as efficient as hand-written assembly. One of the first compiler writers, Grace Hopper, was no stranger to such skepticism as she had said: "I had a running compiler and nobody would touch it...they carefully told me, computers could only do arithmetic; they could not do programs..." Thankfully, compiler research has been prolific and programming languages are able to move away from the one-to-one coorespondences to machine code. This further frees programmers from the underlying computer and enables different programming paradigms and ideas to prosper. 

Regardless of the programming paradigms, all have one thing in common: localized reasoning. 

And regardless of languages, there are good general rules of thumb that applies to all of them, such as [Rob Pike's Rules of Programming](https://users.ece.utexas.edu/~adnan/pike.html).
